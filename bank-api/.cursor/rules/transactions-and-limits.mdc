---
description: 'Nạp/Rút an toàn, transaction Mongo, limit 20M/lần & 500M/ngày, can-withdraw, idempotency.'
globs: ['src/modules/transactions/**/*.ts']
---

# Transaction System & Limits Standards

## Transaction Flow

### Deposit Transaction

```typescript
async deposit(userId: string, depositDto: DepositDto) {
  const { amount, transName, clientRequestId } = depositDto;

  // 1. Check idempotency
  if (clientRequestId) {
    const existing = await this.findExistingTransaction(userId, clientRequestId, TransactionType.DEPOSIT);
    if (existing) {
      return { ...existing, code: 'IDEMPOTENT_REPLAY' };
    }
  }

  // 2. Use MongoDB transaction for consistency
  const session = await this.transactionModel.db.startSession();
  try {
    await session.withTransaction(async () => {
      // Create transaction record
      const transaction = new this.transactionModel({
        accountId: userId,
        transName: transName || 'Deposit',
        transMoney: Decimal128.fromString(amount.toString()),
        transType: TransactionType.DEPOSIT,
        clientRequestId
      });
      await transaction.save({ session });

      // Update account balance
      await this.accountModel.findByIdAndUpdate(
        userId,
        { $inc: { balance: Decimal128.fromString(amount.toString()) } },
        { session }
      );

      // Log audit
      await this.auditService.log({
        actorId: userId,
        action: 'DEPOSIT',
        resource: 'transaction',
        meta: { transactionId: transaction._id, amount, clientRequestId }
      });
    });
  } finally {
    await session.endSession();
  }
}
```

### Withdraw Transaction

```typescript
async withdraw(userId: string, withdrawDto: WithdrawDto) {
  const { amount, transName, clientRequestId } = withdrawDto;

  // 1. Check withdrawal constraints
  const canWithdrawResult = await this.canWithdraw(userId, amount);
  if (!canWithdrawResult.allowed) {
    // Throw appropriate error based on reason
    if (canWithdrawResult.reasons.includes('Insufficient account balance')) {
      throw new ForbiddenException({
        code: 'INSUFFICIENT_FUNDS',
        message: 'Insufficient account balance'
      });
    }
    // Handle other limit violations...
  }

  // 2. Check idempotency
  if (clientRequestId) {
    const existing = await this.findExistingTransaction(userId, clientRequestId, TransactionType.WITHDRAW);
    if (existing) {
      return { ...existing, code: 'IDEMPOTENT_REPLAY' };
    }
  }

  // 3. Use MongoDB transaction
  const session = await this.transactionModel.db.startSession();
  try {
    await session.withTransaction(async () => {
      // Double-check balance in transaction
      const account = await this.accountModel.findById(userId, null, { session });
      if (parseFloat(account.balance.toString()) < amount) {
        throw new ForbiddenException({
          code: 'INSUFFICIENT_FUNDS',
          message: 'Insufficient account balance'
        });
      }

      // Create transaction record
      const transaction = new this.transactionModel({
        accountId: userId,
        transName: transName || 'Withdrawal',
        transMoney: Decimal128.fromString(amount.toString()),
        transType: TransactionType.WITHDRAW,
        clientRequestId
      });
      await transaction.save({ session });

      // Update account balance (subtract)
      await this.accountModel.findByIdAndUpdate(
        userId,
        { $inc: { balance: Decimal128.fromString((-amount).toString()) } },
        { session }
      );

      // Log audit
      await this.auditService.log({
        actorId: userId,
        action: 'WITHDRAW',
        resource: 'transaction',
        meta: { transactionId: transaction._id, amount, clientRequestId }
      });
    });
  } finally {
    await session.endSession();
  }
}
```

## Transaction Limits

### Per-Transaction Limit

```typescript
// Maximum withdrawal per transaction: 20,000,000 VND
const MAX_TRANSACTION_AMOUNT = 20_000_000;

// Check in canWithdraw
if (amount > MAX_TRANSACTION_AMOUNT) {
  reasons.push(
    `Amount exceeds per-transaction limit of ${MAX_TRANSACTION_AMOUNT.toLocaleString()} VND`,
  );
}
```

### Daily Limit

```typescript
// Maximum daily withdrawal: 500,000,000 VND
const DAILY_WITHDRAWAL_LIMIT = 500_000_000;

// Calculate daily used amount
const todayStart = TimezoneUtil.getStartOfDay();
const todayEnd = TimezoneUtil.getEndOfDay();

const dailyUsed = await this.getDailyWithdrawalAmount(
  userId,
  todayStart,
  todayEnd,
);

if (dailyUsed + amount > DAILY_WITHDRAWAL_LIMIT) {
  reasons.push(
    `Amount would exceed daily withdrawal limit of ${DAILY_WITHDRAWAL_LIMIT.toLocaleString()} VND`,
  );
}
```

### Daily Usage Calculation

```typescript
private async getDailyWithdrawalAmount(userId: string, startDate: Date, endDate: Date): Promise<number> {
  const result = await this.transactionModel.aggregate([
    {
      $match: {
        accountId: userId,
        transType: TransactionType.WITHDRAW,
        createdAt: {
          $gte: startDate,
          $lte: endDate
        }
      }
    },
    {
      $group: {
        _id: null,
        total: { $sum: '$transMoney' }
      }
    }
  ]);

  return result.length > 0 ? parseFloat(result[0].total.toString()) : 0;
}
```

## Can-Withdraw Check

### Withdrawal Validation

```typescript
async canWithdraw(userId: string, amount: number) {
  const account = await this.accountModel.findById(userId);
  if (!account) {
    throw new BadRequestException('Account not found');
  }

  const reasons: string[] = [];
  const balance = parseFloat(account.balance.toString());

  // 1. Check account balance
  if (balance < amount) {
    reasons.push('Insufficient account balance');
  }

  // 2. Check per-transaction limit
  if (amount > MAX_TRANSACTION_AMOUNT) {
    reasons.push(`Amount exceeds per-transaction limit of ${MAX_TRANSACTION_AMOUNT.toLocaleString()} VND`);
  }

  // 3. Check daily limit
  const todayStart = TimezoneUtil.getStartOfDay();
  const todayEnd = TimezoneUtil.getEndOfDay();
  const dailyUsed = await this.getDailyWithdrawalAmount(userId, todayStart, todayEnd);

  if (dailyUsed + amount > DAILY_WITHDRAWAL_LIMIT) {
    reasons.push(`Amount would exceed daily withdrawal limit of ${DAILY_WITHDRAWAL_LIMIT.toLocaleString()} VND`);
  }

  return {
    allowed: reasons.length === 0,
    reasons,
    balance,
    dailyUsed,
    dailyLimit: DAILY_WITHDRAWAL_LIMIT
  };
}
```

## Timezone Handling

### Vietnam Timezone

```typescript
// src/common/utils/timezone.util.ts
export class TimezoneUtil {
  static readonly TIMEZONE = 'Asia/Ho_Chi_Minh';

  static getStartOfDay(date: Date = new Date()): Date {
    const zonedDate = utcToZonedTime(date, this.TIMEZONE);
    const startOfDayZoned = startOfDay(zonedDate);
    return zonedTimeToUtc(startOfDayZoned, this.TIMEZONE);
  }

  static getEndOfDay(date: Date = new Date()): Date {
    const zonedDate = utcToZonedTime(date, this.TIMEZONE);
    const endOfDayZoned = endOfDay(zonedDate);
    return zonedTimeToUtc(endOfDayZoned, this.TIMEZONE);
  }
}
```

### Daily Limit Reset

- Daily limits reset at 00:00 VN time
- All calculations use Vietnam timezone
- UTC conversion for database storage

## Idempotency

### Client Request ID

```typescript
export class TransactionDto {
  @ApiPropertyOptional({ description: 'Client request ID for idempotency' })
  @IsOptional()
  @IsString()
  @IsNotEmpty()
  clientRequestId?: string;
}
```

### Idempotency Check

```typescript
private async findExistingTransaction(
  userId: string,
  clientRequestId: string,
  transType: TransactionType
) {
  return this.transactionModel.findOne({
    accountId: userId,
    clientRequestId,
    transType
  });
}

// In deposit/withdraw methods
if (clientRequestId) {
  const existing = await this.findExistingTransaction(userId, clientRequestId, transType);
  if (existing) {
    return {
      ...existing.toJSON(),
      code: 'IDEMPOTENT_REPLAY'
    };
  }
}
```

### Idempotency Response

```typescript
// When duplicate clientRequestId is found
{
  success: true,
  data: {
    id: 'transaction-id',
    amount: 1000000,
    transType: 1,
    clientRequestId: 'deposit-123',
    createdAt: '2024-01-01T00:00:00.000Z',
    code: 'IDEMPOTENT_REPLAY' // Indicates this is a replay
  }
}
```

## Database Schema

### Transaction Schema

```typescript
@Schema({ timestamps: true })
export class Transaction {
  @Prop({ type: Types.ObjectId, ref: 'Account', required: true, index: true })
  accountId: Types.ObjectId;

  @Prop({ required: true, trim: true })
  transName: string;

  @Prop({
    type: Decimal128,
    required: true,
    validate: {
      validator: function (value: Decimal128) {
        return parseFloat(value.toString()) > 0;
      },
      message: 'Transaction amount must be greater than 0',
    },
  })
  transMoney: Decimal128;

  @Prop({ enum: TransactionType, required: true })
  transType: TransactionType;

  @Prop({ unique: true, sparse: true, index: true })
  clientRequestId?: string;

  createdAt: Date;
}

// Indexes for performance
TransactionSchema.index({ accountId: 1, createdAt: -1 });
TransactionSchema.index({ clientRequestId: 1 }, { unique: true, sparse: true });
```

### Account Schema

```typescript
@Prop({
  type: Decimal128,
  default: Decimal128.fromString('0')
})
balance: Decimal128;
```

## Error Handling

### Transaction Errors

```typescript
// Insufficient funds
throw new ForbiddenException({
  code: 'INSUFFICIENT_FUNDS',
  message: 'Insufficient account balance',
});

// Per-transaction limit
throw new ForbiddenException({
  code: 'LIMIT_PER_TRANSACTION',
  message: `Amount exceeds per-transaction limit of ${MAX_TRANSACTION_AMOUNT.toLocaleString()} VND`,
});

// Daily limit
throw new ForbiddenException({
  code: 'DAILY_LIMIT_EXCEEDED',
  message: `Amount would exceed daily withdrawal limit of ${DAILY_WITHDRAWAL_LIMIT.toLocaleString()} VND`,
});
```

### Validation Errors

```typescript
// Amount validation
@IsPositive({ message: 'Amount must be greater than 0' })
@Type(() => Number)
amount: number;

// Transaction name validation
@IsOptional()
@IsString()
@IsNotEmpty()
transName?: string;
```

## CSV Export

### CSV Generation

```typescript
async exportTransactions(userId: string, query: TransactionQueryDto) {
  const transactions = await this.getTransactionsForExport(userId, query);

  // Add BOM for Excel compatibility
  const bom = '\uFEFF';

  const csvColumns = [
    'ID', 'Account ID', 'Transaction Name',
    'Amount (VND)', 'Type', 'Client Request ID', 'Created At'
  ];

  const csvData = transactions.map(t => [
    t.id,
    t.accountId,
    this.escapeCsvCell(t.transName),
    t.transMoney,
    t.transType === 1 ? 'Deposit' : 'Withdraw',
    t.clientRequestId || '',
    t.createdAt.toISOString()
  ]);

  return bom + stringify([csvColumns, ...csvData]);
}
```

### CSV Injection Protection

```typescript
private escapeCsvCell(cell: string): string {
  if (!cell) return '';

  // CSV injection protection
  const firstChar = cell.charAt(0);
  if (['+', '-', '@', '='].includes(firstChar)) {
    return `'${cell}`;
  }

  return cell;
}
```

## Performance Optimization

### Database Indexes

```typescript
// Account balance queries
AccountSchema.index({ _id: 1 });

// Transaction queries
TransactionSchema.index({ accountId: 1, createdAt: -1 });
TransactionSchema.index({ clientRequestId: 1 }, { unique: true, sparse: true });
TransactionSchema.index({ transType: 1 });
TransactionSchema.index({ createdAt: 1 });

// Daily usage aggregation
// Use compound index for efficient aggregation
```

### Aggregation Pipeline

```typescript
// Efficient daily usage calculation
const pipeline = [
  {
    $match: {
      accountId: userId,
      transType: TransactionType.WITHDRAW,
      createdAt: { $gte: todayStart, $lte: todayEnd },
    },
  },
  {
    $group: {
      _id: null,
      total: { $sum: '$transMoney' },
    },
  },
];
```

### Pagination

```typescript
// Efficient pagination with skip/limit
const skip = (page - 1) * pageSize;
const total = await this.transactionModel.countDocuments(filter);

const transactions = await this.transactionModel
  .find(filter)
  .sort({ createdAt: -1 })
  .skip(skip)
  .limit(pageSize)
  .lean();
```

## Testing Transactions

### Unit Tests

```typescript
describe('TransactionsService', () => {
  it('should deposit successfully', async () => {
    mockTransactionModel.findOne.mockResolvedValue(null);
    mockTransactionModel.save.mockResolvedValue(mockTransaction);

    const result = await service.deposit(userId, depositDto);
    expect(result).toBeDefined();
    expect(mockAccountModel.findByIdAndUpdate).toHaveBeenCalled();
  });

  it('should reject withdrawal exceeding daily limit', async () => {
    jest.spyOn(service, 'canWithdraw').mockResolvedValue({
      allowed: false,
      reasons: ['Amount would exceed daily withdrawal limit'],
      balance: 1000000000,
      dailyUsed: 490000000,
      dailyLimit: 500000000,
    });

    await expect(service.withdraw(userId, withdrawDto)).rejects.toThrow(
      ForbiddenException,
    );
  });
});
```

### E2E Tests

```typescript
describe('Transaction Flow', () => {
  it('should complete deposit and withdrawal flow', async () => {
    // Login
    const loginResponse = await request(app.getHttpServer())
      .post('/auth/login')
      .send(loginData);

    const token = loginResponse.body.data.accessToken;

    // Deposit
    await request(app.getHttpServer())
      .post('/transactions/deposit')
      .set('Authorization', `Bearer ${token}`)
      .send({ amount: 1000000 })
      .expect(201);

    // Withdraw
    await request(app.getHttpServer())
      .post('/transactions/withdraw')
      .set('Authorization', `Bearer ${token}`)
      .send({ amount: 500000 })
      .expect(201);
  });
});
```

## Monitoring & Alerting

### Transaction Metrics

- Transaction volume per day
- Transaction value per day
- Failed transaction rate
- Average transaction amount
- Daily limit usage

### Security Monitoring

- Large transaction alerts
- Suspicious transaction patterns
- Failed withdrawal attempts
- Idempotency violations

### Performance Monitoring

- Transaction processing time
- Database query performance
- Daily limit calculation time
- CSV export performance
